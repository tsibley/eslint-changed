#!/usr/bin/env python3
import os
import re
import subprocess
import sys
from itertools import takewhile
from pathlib import Path


def MAIN(args):
    if args:
        print("Arguments were provided but no arguments are taken", file = sys.stderr)
        return 1

    touched_lines = list(git_lines_added(files = ("*.js", "*.jsx")))
    touched_files = list(set(str(filename) for filename, _ in touched_lines))

    touched = set(
        (filename, line)
            for filename, lines in touched_lines
            for line in lines)

    linty_lines = [
        lint for lint in eslint(touched_files)
           if (lint[0], lint[1]) in touched
    ]

    for lint in linty_lines:
        print(":".join(map(str, lint)))

    return 1 if linty_lines else 0


def eslint(files):
    if not files:
        return []

    cwd = Path.cwd()
    cmd = [
        "npx",
        "eslint",
        "--ext", ".js,.jsx",
        "--format", "unix",
        *files
    ]

    # eslint exits 1 if output exists, but that's ok!  Output, even in Unix
    # format, ends with a blank line and then a count of total linting errors.
    # We ignore that.
    def not_blank(line):
        return line != ""

    lines = [
        re.split(r':', line, 4)
            for line in takewhile(not_blank, capture_output(cmd, check = False))
    ]

    def as_tuple(field):
        return (
            Path(field[0]).relative_to(cwd),    # filename
            int(field[1]),                      # line
            int(field[2]),                      # column
            field[3])                           # error

    return list(map(as_tuple, lines))


def git_lines_added(since_ref = "master", files = ()):
    cwd_prefix = capture_output(["git", "rev-parse", "--show-prefix"])[0]
    merge_base = capture_output(["git", "merge-base", since_ref, "HEAD"])[0]

    HUNK_HEADER = r'^@@ -\d+(?:,\d+)? \+(?P<start>\d+)(?:,(?P<length>\d+))?'

    filename = None

    for line in capture_output(["git", "diff", "--no-ext-diff", "-U0", merge_base, "--", *files]):
        if line.startswith("+++ b/"):
            filename = Path(ltrim("+++ b/", line)).relative_to(cwd_prefix)

        elif filename and line.startswith("@@"):
            match = re.search(HUNK_HEADER, line, re.ASCII)
            assert match, "Line starting with @@ didn't match hunk header pattern"

            # A missing length (None) means a length of 1, i.e. the ending line
            # is the same as the starting line.  A length of 0 means the hunk
            # is a pure deletion.
            start  = int(match.group("start"))
            length = int(match.group("length") or 1)

            if length:
                # insertion (+) filename, line interval [start, end)
                yield (filename, range(start, start + length))


def capture_output(argv, check = True):
    """
    Run the command specified by the argument list and return a list of output
    lines.

    This wrapper around subprocess.run() exists because its own capture_output
    parameter wasn't added until Python 3.7, and I'm aiming for compat with 3.5.
    """
    result = subprocess.run(
        argv,
        stdout = subprocess.PIPE,
        stderr = subprocess.DEVNULL,
        check  = check)

    return result.stdout.decode("utf-8").splitlines()


def ltrim(prefix, string):
    return re.sub('^' + re.escape(prefix), '', string)


if __name__ == "__main__":
    try:
        sys.exit(MAIN(sys.argv[1:]))

    except BrokenPipeError:
        # From https://docs.python.org/3/library/signal.html#note-on-sigpipe:
        #
        #    Python flushes standard streams on exit.  Redirect remaining output
        #    to /dev/null to avoid another BrokenPipeError at shutdown.
        #
        devnull = os.open(os.devnull, os.O_WRONLY)
        os.dup2(devnull, sys.stdout.fileno())

    except KeyboardInterrupt:
        # Print a newline to leave cleaner console output
        print()
